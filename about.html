<DOCTYPE html>
    <html>
        <head>
         <meta charset="utf-8">
         <title>Overhelmed</title>
         <link rel="stylesheet" href="./css/aboutCSS.css">
         <script async defer src="https://buttons.github.io/buttons.js"></script>
         </head>
         <body>
	<section>
		<div style="position:fixed;bottom:8px;right:4px;z-index: 2;">
			<a class="github-button" href="https://github.com/AlnyfoL/AlnyfoL.github.io" data-color-scheme="no-preference: dark; light: dark; dark: dark;" data-size="large" aria-label="GitHub">PROJET GitHub</a>
		</div>
		<div class="content">
			<div>
				<br><br><h2>Le Projet</h2>
				<p>Sur cette page, vous trouverez l'avancement du projet qui est constitué de l'évolution de la map, des animations, de la création de l'interface de jeu et plus encore. Il expose également les difficultés rencontrées lors de la conception de notre jeu.</p>
			</br></br>
				<h4>Sommaire:</h4> </li>
						<ul>
							<br> 

							<li> <a href="#commencement"> Le commencement </a> </li>
							<br>
	
							<li> <a href="#version1"> La première version </a> </li>
							<br>
		
							<li> <a href="#version2"> La deuxième version </a> </li>
							<br>
							
							<li> <a href="#dec"> Découverte </a> </li>
							<br>
							
							<li> <a href="#diff"> Les difficultés et les solutions </a> </li>
							<br>
							
							<li> <a href="#logo"> Le logo </a> </li>
							<br>
							
						</ul>
			</div>
		</div>
		<div class="imgBx" id="perso">
			<img src="css/logo.PNG">
		</div>
        <ul class="nav">
            <li><a  href="index.html">Accueil</a></li>
            <li><a class="active" href="about.html">Le Projet</a></li>
			<li><a href="jeu.html">Mode d'emploi</a></li>
            <li><a href="download.html">Télécharger</a></li>
            <li><a href="album.html">Albums</a></li>
            <li><a href="référence.html">Références</a></li>
			<li><a href="membre.html">Le Groupe</a></li>

        </ul>
	</section>
	<section id="v1">
		<div class="content" id="commencement">
			<div>
				<h3>Le commencement</h3>
				<p>Lors de la conception initiale de notre projet, nous étions pratiquement surs
					que nous allions faire un jeu vidéo. Cependant, nous avions de nombreuses idées
					différentes, telles qu’un jeu de parkour 3D, un jeu “top-down” à la “Pokémon”
					ou encore un jeu d’infiltration ressemblant a “Hitman”. Finalement, nous avons
					opté pour un jeu de survie multijoueur en FPS (“First-person shooter”) de type
					PvE (“Player vs Environment”). De 1 à 4 joueurs, le but est de survivre le plus
					longtemps possible à des vagues de zombies dans un camp militaire abandonné.
					Des améliorations seront possible tout au long de l’aventure et de nombreux
					événement spéciaux occurreront durant différents tours.</p>
			</div>
		</div>
	</section>
	<section>
		<div class="content" id="version1">
			<div>
				<h2>Première Version </h2>
				<div class="imgBx" id="map2">
					<img src="img/char + voiture.PNG">
				</div>
				<h3>Model 3D</h3>
				<p>  La map été inspirée de camp militaire issu de jeu vidéo tel que par exemple Call of Duty Warzone ou d'images trouvées sur le Web. Notre Map est constitué d'élement réalisé par Blender ou issu de l'AssetStore est tous assemblé sur le logiciel Unity. Pour cette première version, notre map représente un camp militaire presque complet, il ne lui manque que quelques détails tel que des portes aux batiments et elle a également quelques soucis de proportinnalité générale.
					Concernant le skin de nos personnages, nous avons utilisé Mixamo pour upload les quatre skins voulu pour nos personnages et le skin des zombies.
				</p>
				<br>
				<br></br><br></br>
				<h3>Animation 3D</h3>
				<p> 
					D'abord, il était important que le personnage puisse être mobile, qu'il puisse se déplacer dans toutes les directions. Le personnage se déplace en avant, en arrière, à gauche et à droite. Nous avons également ajouté la fonctionnalité de saut, et tout le code qui va avec afin que le personnage ne puisse sauter si et seulement si il est au sol. Une fois toutes ces possibilités ajoutées, nous devions nous occuper du visuel, car jusque-là, le personnage va là où on lui demande, mais en gardant la posture initiale. Ainsi, nous nous sommes aidés de Mixamo, pour télécharger les animations de marche, de course, de saut, et de respiration (le joueur est inactif, il reste sur place).</p>
				</p>
			</br>
				<div class="imgBx" id="ani">
					<img src="img/Capture Anim Player.png">
				</div>
				<br></br><br></br>
				<h3>Engine</h3>
				<p>Premièrement, les déplacements du personnage ayant déjà été développé pour l'animation 3D, Il ne manque plus que les collisions afin de permettre au personnage d’empêcher le personnage de rentrer dans un mur ou un autre joueur. Cela a été fait en utilisant la même méthode que pour le TD d’AR/VR. 

					Deuxièmement, le control de la caméra grâce à la souris est au cœur même des FPS. Afin de l’implémenter l’utilisation des classes et méthodes de la librairie “UnityEngine” fut nécessaire. Pour permettre un certain réalisme il a fallu empêcher la caméra de pouvoir faire une rotation entière sur l’axe Y. Elle est donc bloquée au minimum au niveau des pieds du personnage et au maximum au niveau de sa tête. 
					
					Troisièmement, l’implémentation des armes et de la possibilité de tirer. Pour permettre cela, la création de 6 nouvelles class fut requise. Item et Gun, deux classes abstraites permettant une création plus simple d’armes différentes. ItemInfo et GunInfo, deux classes deux classes stockant le nom et les dégâts de l’armes. La class IDamageable est une class dont hérite tous les objets pouvant prendre des dêgats. Et enfin SingleShotGun, la classe définissant notre arme. Dans celle-ci, la fonction Use est utilisé que lorsque PlayerController détecte l’utilisation du clic droit et pose un impact sur la position du premier objet touché et lui retire les dégâts de l’armes s'il peut en prendre. Dans cette rubrique malgré que cela n’était pas encore nécessaire à la soutenance, l’ajout d’une seconde arme ainsi que de la possibilité de changer d’une arme à une autre a déjà été implémenté. 
					</p>
					<br></br>
				<h3>Game Management</h3>
				<p>Cette partie constite à pouvoir gérer les kills, morts, spawns et respawns des joueurs. L'initialisation des joueurs par un RoomManager et PlayerManager a paru opportun.  En effet la class RoomManager permet d’initié une instance de la class  PlayerManager par joueur. Cette instance devra initialiser une instance de la class PlayerController qui apparaitra sur un point de “spawn” aléatoire sur la carte. Elle sera détruite dès que les points de vie seront à 0, puis réinitialisé par la suite. La class SpawnManager permet de gérer les points d’apparition et sa méthode d’en obtenir un aléatoirement qui sont initialisé avec la class Spawnpoint. Il fut aussi nécessaire de synchroniser certaine information entre les différents joueurs, tel que les dégâts encaissés et fait. Pour faire cela les méthodes de la librairie photon fut utilisé.</p>
				<br></br>
				<h3>Interfaces</h3>
				<p>Avant le menu principal, nous avons donc du insérer un écran de chargement pour éviter les erreurs lorsque un utilisateur essaye de créer ou rejoindre une “room” avant que la connection au server soit fini.
				Ensuite, il a fallu créer un script “MenuManager” permettant de gérer l'ouverture et la fermeture des menus (l'écran de chargement, le menu principal, le menu où l'on créer la “room”, etc.).
				Nous avons aussi fait un menu d'erreur lorsque l'on arrive pas à créer une “room”.
				Nos menus sont composés de “Button” permettant différentes actions et de “InputField” pour récupérer du texte de l'utilisateur.
				L'utilisation des classes préfaites de PUN furent aussi très utiles tel que la classe “Player”, notamment pour donner un pseudonyme aux joueurs ou encore “RoomInfo” pour identifier et distinguer chacunes d'entre elles. 
				La partie “Interfaces” est donc à jour avec l'objectif fixé pour la première soutenance : on a bien un menu principal qui nous permet d'effectuer les actions dont on a besoin. Il resterait juste à le rendre un peu plus esthétique puisqu'il est assez terne pour l'instant (on peut s'occuper de cela plus tard, voire même pour la dernière soutenance puisque cela est de moindre importance).
				De plus, nous avons pu prendre de l'avance sur cette partie puisque nous avons déjà pu intégrer les pseudos qui s'affichent au-dessus des joueurs. Pour cela, il y a simplement besoin de faire que le texte créé au-dessus du joueur s'oriente constamment dans la direction de la caméra.
			</p>
			<div class="imgBx" id="int">
				<img src="img/Capture d’écran (1173).png">
				<img src="img/Capture d’écran (1175).png">
				<img src="img/Capture d’écran (1178).png">
				<img src="img/Capture d’écran (1176).png">
			</div>
			<br><br>
			<h3>Réseau</h3>
			<p>
				Tout d'abord il a fallu implémenter et paramétrer l'application Photon.
				Sur leur site web (photonengine.com), on peut créer une nouvelle application Photon à partir de son dashboard. On obtient ainsi une App ID, propre à notre server Photon.
				Ensuite, on a dû importer le package PUN 2, une sorte de boîte à outils permettant de mettre en relation notre projet Unity avec son server Photon dédié (grâce à son App ID).
				Le fichier PhotonServerSettings nous permet alors de gérer quelques paramètres, tel que la possibilité de fixer la région en EU pour éviter tout problème de latence. 
			</p>
		</br></br>
			</div>
		</div>
		
	</section>
	<section>
		<div class="content" id="version2">
			<div>
				<h2>Deuxième Version </h2>
				<br></br>
				<div class="imgBx" id="map">
					<img src="img/version 2 map.PNG">
				</div>
				<h3>Model 3D</h3>
				<p> 
					Concernant la partie Model 3D, nous avions déjà bien avancé à la première version, 
					c'est pourquoi pour la deuxième version nous devions simplement perfectionner la carte, c'est-à-dire rajouter des portes, 
					vérifier que chaque élément possède un collider, il s'agit d'un composant qui permet d'éviter que notre personnage 
					se retrouve à l'intérieur des éléments qui constituent notre map, et nous devions également regarder pour que tous 
					les éléments qui composent la map soit proportionnels entre eux. Ces détails sont encore à perfectionner pour la version finale
					mais sinon notre carte est complète au niveau des éléments qui la composent.
					 Celle-ci est donc inspiré d'un camp militaire dans lequel il existe plusieurs zones. Il y a des zones desaffectées, un camp d'entrainement, un espace santé, une zone de tir, un parking pour les voitures etc.
					Nous avons donc une map plutôt complète. Vous pouvez retrouver des photos de celle-ci dans la rubrique Album puis dans l'espace Map.
					<br><br>Pour les personnages, comme il s'agit d'un FPS, nous avons <br> ajouté un modèle de bras avec une arme pour le joueur.</br> </br></br>
				</p>
				<br></br>
				<h3>Animations 3D</h3>
				<p> 
					En ce qui concerne la modélisation 3D, nous nous sommes plus particulièrement focalisés sur la vue en première personne.
					Ainsi, le personnage peut se déplacer tout en tenant l'arme dans les mains.
					 A cela nous avons ajouté une animation de tir, qui s'execute lorsque le clic-gauche
					  est activé. Lorsque l'on tire une balle, une petite explosion a lieue au canon de l'arme
					   afin d'ajouter une touche de réel. Enfin, une nouvelle animation, le rechargement de l'arme, 
					   se lance dès que l'utilisateur appuie sur la touche R, mais aussi automatiquement quand 
					   l'arme n'a plus de balle dans le chargeur alors que l'utilisateur essaye de tirer. Jusque-là, cela 
					   concerne le personnage que l'on incarne dans le jeu, mais les zombies aussi ont leurs animations.
					 En effet, les zombies peuvent désormais se déplacer tout en ayant un corps animé, et ont également une animation d'attaque.
					</p>
				<br>
				<br></br>
				<h3>Audio</h3>
				<p> 
					La partie Audio est certainement la partie la moins compliquée que nous avons dû faire jusqu'ici. Néanmoins, il est important 
					de choisir des musiques adéquates à notre thème de jeu afin que le joueur soit, dès les menus, plongé dans l'atmosphère d'Overwhelmed.
					Pour cela, nous avons trouvé Mystical Theme d'Alexandr Zhelanov qui tourne dans le menu du jeu. Et après le lancement d'une partie,
					Creepy Forest de Brandon Morris est en fond. Ceci concerne les musiques du jeu, mais ce ne sont pas les seuls éléments auditifs qui le composent. 
					En effet, lorsque l'on tire une balle, un coup de feu est activé.
				</p>
			</br>
			<br></br>
				<h3>Engine</h3>
				<p>Pour cette nouvelle version Lucas avait à implémenter une intelligence artificielle qui pouvait servir d'ennemies. Afin de faire cela, 
					il utilisa principalement les méthodes de la classe NavMeshAgent de 
					la librairie UnityEngine. L'initialisation des zombies se fait grâce à la classe EnnemySpawneurs qui pour l'instant fait 
					apparaitre régulièrement un zombi sur chaque point d'apparition. Le zombi est initié avec de nombreuses classes telles que :
					 Chasing, EnnemyType, KillReward et HealthManager. Chasing permet de gérer les déplacements du zombi ainsi que sa recherche du
					  chemin vers le joueur. Elle permet aussi de gérer les attaques du zombi envers le joueur. EnnemyType, Kill Reward et HealthManager 
					  représentent les caractéristiques du zombi. C'est-à-dire le type d'ennemie en question, l'expérience et l'argent reçu à son élimination 
					  et ses actuels points de vie. 
					Tout ceci a été dévelopé dans un projet externe et n'a pas encore été rattaché au projet principal, car la map est trop complexe pour
					 permettre de simple essaie de recherche de chemin expérimentale.  Et donc une map plus simpliste était préférable pour
					  le développement.</p>
					  <br></br>
					  <h3>Interfaces</h3>
					  <p>La partie interface fut relativement légère comparée à ce qui fut fait dans cette partie pour 
						  la première soutenance. Effectivement, pour cette soutenance, nous avions prévu d'ajouter quelques éléments 
						  sur l'interface utilisateur du joueur. Cependant, la plus part des valeurs que nous voulions afficher dépende 
						  d'autres fonctionnalités et nécessite un fort avancement dans le projet pour pouvoir être implémenté pleinement. 
						  Par exemple, pour afficher l'argent que possède le joueur sur son interface utilisateur, il faut que tout le système
						   de gestion de l'argent soit déjà implémenté, c'est à dire aussi que les zombies doivent 
						  être entièrement intégré au préalable, etc. Alors un des seuls éléments de l'interface qui valait le coût d'implémenter 
						  dès à présent fut la barre de santé. 
						Pour cela, ce n'était point trop compliqué : sur un canvas  (un plan, en 2 dimensions, qui s'affiche directement 
						sur la caméra du joueur), on place 2 images, une pour la barre de santé en tant que tel, et une pour son arrière-plan.
						 Ensuite, il a fallu juste faire en sorte que dans notre fonction qui gère lorsque que l'on prend des dégâts, l'image qui 
						 représente notre barre de santé diminium en fonction d'un ratio ( nombre de vie actuel nombre de vie total pour être précis).
						  Enfin, il faut bien faire attention à ce que chaque barre de santé s'affiche sur le bon joueur car de base, elles s'affichent 
						  toutes sur chaque joueur (on utilise pour cela Photon ; plus de détail sur cela dans la partie ci-dessous).</p>
						  <br></br>
				<h3>Game Management</h3>
				<p>Afin d'implémenter un système de round autrement définie par vagues de zombi. Il a donc paru nécessaire d'améliorer les
					 statistiques des zombis à la suite de la validation 
					 d'un objectif. Qui pour l'instant se manifeste sous la forme de temps. Pour cela, dans la classe EnnemySpawner 
					 la fonction updatée cherche si la condition est remplie. Si oui les statistiques des zombis à leurs prochaines apparitions sont augmentées.
					Un système d'argent et d'expérience a aussi été implémenté, il permettra par la suite d'acheter de meilleures armes ou des 
					améliorations. Ceci a aussi été seulement implémenté sur le projet externe car il se devait d'être avec les zombis.</p>
					<br></br>
				<h3>Réseau</h3>
				<p>Dans la partie réseau, le plus compliqué est de mettre en place le server dédié au jeu ainsi que de réaliser un système 
				permettant au joueurs de se retrouver et de se connecter à la même partie. Comme ces éléments sont importants et doivent 
				être implémentés dès le début du projet, nous avions fait cela pour la première soutenance. Pour cette partie, il ne reste
				 alors plus de grande étape mais uniquement bien faire attention à la synchronisation des éléments communs aux joueurs. 
				 Par exemple, il ne faut pas oublier de faire en sorte que les positions des joueurs (et leurs changements de position) 
				soient biens les mêmes sur son propre jeu et pour les autres joueurs. Heuresement, le service multijoueur que nous utilisons, 
				intitulé Photon, nous permet de gérer cela assez facilement. En effet, grâce à Photon, 
				nous avons à disposition deux composants préfaits pour s'occuper de ça.
			</p><br>
			<br></br>
				<h3>Autres \ Détails </h3>
				<p>Une partie dont nous n'avions pas réellement évalué l'importance est tout ce qui corresponds aux éléments 
				qui ne se retrouvent dans aucune des catégories précédentes. En effet, la conception d'un jeu vidéo nécessite de 
				nombreux secteurs très différents, certains plus ou moins importants. Il y en a notamment qui sont plus rapides et 
				plus minimes mais bien les implémenter apporte tout de suite plus de caractère au jeu.
				Par exemple, nous avons pu améliorer l'éclairage de notre jeu en ajoutant du brouillard ambiant, du post-traitement sur la caméra
				des joueurs (des effets visuels qui s'ajoute sur le point de vu des joueurs pour rendre la scène plus intense/dramatique). 
				Nous avons aussi ajouter une Skybox (une image qui fait effet de ciel) ainsi que modifier les paramètres de la  Directional
				Light (une lumière qui fait effet de soleil) pour donner cet aspect de coucher de soleil.
				Cela nous a permis de passer d'un rendu assez terne vers quelque chose de bien plus dynamique, éclatant et intéressant.</p></br>
				<div class="imgBx" id="ani">
					<img src="img/v2 autre (2).png">
				</div>
				<br><br>
				<br></br>
				<h3>Site Web</h3>
			<p>Concernant le Site Web, notre toute premiere version de celui-ci était déjà pas mal avancé. Nous avons cependant opté plus sur le contenu que sur le rendu, et l'esthétique malgré que celui-ci est déjà un rendu qui était très convenable, cependant il manquait de finesse.
				De plus, nous l'avions déjà rendu public en le publiant sur le Web car comme celui-ci montre l'avancement de notre projet, autant que tout le monde le voit avancer en temps réel. 
				Le site Web s'inspire des couleurs de notre logo soit le noir et l'orange, ce qui le rend totalement à l'image de notre jeu. 
				Nous voulons que les personnes qui suivent notre projet puissent le faire à l'aide de notre site qui est actualisé à chaque fois que nous avançons sur notre projet.
			</p></br></br>
			</div>
		</div>
	</section>
	<section>
		<div class="content" id="dec">
			<div>
				<h2>Découverte </h2>
				<p>Dans la création du projet, nous avons déjà pu découvrir plusieurs choses. En effet, concernant la partie “Model” 3D, 
					nous avons pu manipuler des outils comme Blender et Unity, cela nous a permis d'acquérir de l'expérience, mais également de se perfectionner 
					dans l'utilisation de ces outils.
					<br><br>La partie “Animation” 3D nous a également permis de manipuler l'outil animator de Unity qui est plus complexe qu'il ne paraît. 
					En effet, cela n'a pas été évident de comprendre son fonctionnement, et l'organisation du schéma n'est pas géniale, puisque plus 
					on ajoute d'animation, et plus il faut lier les cases avec les flèches, ce qui complique la lisibilité de notre schéma. Il faut 
					également être rigoureux au niveau du script C# et manipuler correctement les paramètres afin que les animations soient fluident et 
					s'activent en temps voulu. 
					Mais une fois que tout est bien reglé, c'est agréable de voir que les animations sont bien synchronisées et sont fluides.</p></br></br>
			</div>
		</section>
		<section>
			<div class="content" id="diff">
				<div>
					<h2>Les Difficultés rencontrées & les Solutions envisagées </h2>
						 <h1>Début du projet</h1>
					<p>Nous avons rencontré plusieurs difficultés ce qui est très courant dans un projet.
						Tout d'abord, concernant la partie <b>Model 3D</b>, le partage de la map issue de Unity3D, nous a posée de
						 nombreux soucis car le transfert vis à Github ne voulait pas se faire car notre map était 
						 trop volumineuse. Nous avons réussi à régler le souci après de nombreuses recherches. 
						 Cependant notre map reste tout de même assez volumineuse malgré le fait que nous avons par 
						 exemple descendu la qualité des textures. Ce souci est dû à nos assets car nous voulons un 
						jeu réaliste donc ceux-ci sont volumineux dû à leur niveau de qualité.
						<br><br>Concernant la partie <b>Animation 3D</b>, l'animator n'est pas de tout repos. 
						En effet, cet outil peut devenir une source de problème s'il est mal organisé. 
						De plus, son fonctionnement nécessite une certaine quantité de connaissances car
						 il est rempli de fonctionnalités diverses qui le rend d'autant plus complexe car
						  pour faire une chose il peut y avoir plusieurs possibilités de réalisation. Cependant,
						   avec du recul et de l'aide, nous arrivons à nous en sortir et à obtenir les résultats attendus. 
						</br></br>Pour ce qui est des parties <b>réseau et interfaces</b>, cela à pris du temps de comprendre 
						les différentes classes et méthodes de Photon et de savoir quand et comment les utiliser.
						 Malgré que la plupart des méthodes porte des noms assez transparents, le principe n'est
						  souvent pas très intuitif ou clair. De plus, la documentation Photon n'est pas des plus pratiques à utiliser. 
						  <br><br>Pour ce qui concerne <b>l'Engine et le Game Management</b>, il fut 
						très compliqué de comprendre comment différencier un joueur d'un autres 
						et d'utiliser les méthodes et class préfab de UnityEngine car la documentation n'est pas des plus clairs.</br></br></p>
						<h1>Milieu du projet</h1>
						<p>Concernant le <b>site Web</b>, les difficultés rencontrées sont principalement des problèmes de mise en page qui se résoude assez 
						facilement si on s'est se renseigner correctement sur le Web:. La plus grande difficultée est de trouver l'inspiration pour 
						l'esthétique du site.
						<br></br>L'enjeu actuel dans la partie <b>Animation 3D</b> est de pouvoir afficher les autres joueurs dans leur 
						entièreté et pas seulement des bras et l'arme qui va avec. En effet, les FPS qui ne sont pas en 
						multijoueur sont plus faciles à faire car seule une arme suffit, personne ne constatera une arme flotter dans 
						l'air. Ici nous devons ajouter un visuel car il est important de rappeler qu'il pourra y avoir 4 joueurs dans
						 la version finale de notre jeu. Certes, nous sommes dans les temps pour ce 
						qui est des avancées à faire pour les soutenance, mais nous avons déjà pris conscience de la difficulté qui se dresse devant nous.  </p>
					</div>
			</section>
			<section>
				<div class="content" id="logo">
					<div>
						<h2>Le logo</h2>
						<p>Un élément très important d’un jeu, c’est l’esthétique. Concernant le logo, et quant au choix des graphismes,
							 nous avons voulu choisir un style plutôt réaliste pour qu’il attire l’œil même si nous savons que dans le jeu, 
							 les zombies ainsi que les armes ne seront pas aussi réalistes. De plus, ce logo est artisanal.</p></br></br>
					</div>
					<div class="imgBx" id="ani">
						<img src="img/logooff.png">
					</div>
				</section>
</div>
    </body>
    </html>
